-- Modify the tic-tac-toe program to choose a move
-- that attempts to take the quickest route to win
-- by calculating the depths of resulting game trees
-- and selecting the move that results in a tree with 
-- the smallest depth



-- Update minimax to also label each node
-- with the shortest route of it's best subsequent move
-- (Winning > Drawing > Losing)
minimax :: Tree Grid -> Tree (Grid,Player,Int)                             
minimax (Node g [] _)                                                    
   | wins O g  = Node (g,O,0) [] -- Leaf nodes have child depth of 0, no further nodes to visit                                          
   | wins X g  = Node (g,X,0) []                                          
   | otherwise = Node (g,B,0) []                                          
minimax (Node g ts _)                                                     
   | turn g == O = Node (g, best, shortest) ts'                             
   | turn g == X = Node (g, best, shortest) ts'                             
                   where                                                
                      ts' = map minimax ts -- Update child nodes of current node                             
                      ps  = [p | Node (_,p,_) _ <- ts'] -- Player list of each child node
					  ds  = [d | Node (_,_,d) _ <- ts'] -- Depth list of each child node 
					  zs = zip ps ds                    -- [(p,d),(p,d),(p,d)]
					  best = if (turn g == O) then minimum ps else maximum ps -- Of children find best type (Win > Draw > Loss)
					  fs = filter (\x -> fst x == best) zs -- Here we remove any children that are do not lead to a best state 
					  shortest = 1+ (snd $ minimum fs) -- With all tuple having an equal first element, minimum can will sort on second (depth)
					                                   -- We take the child with the smallest depth and add 1 representing the no. moves to make from root 


-- Now modify best move to select the child with the lowest depth (moves - 1 of root)
bestmove :: Grid -> Player -> Grid                                      
bestmove g p = head [g' | Node (g',p',d') _ <- ts, (p' == best) && ((moves - 1) == d')]             
               where                                                    
                  tree = prune depth (gametree g p)                     
                  Node (_,best,moves) ts = minimax tree                       
                                                                        
{-

We'll consider the following grid and the current player being O

O | X | O 
X | O | _
_ | X | _

Using the updated bestmove (named bestmoved)

g = [[O,X,O],[X,O,B],[B,X,B]]
bestmoved g O
[[O,X,O],
 [X,O,B],
 [O,X,B]]

-- A winning move is the returned best move 

-- Compared to the original implementation 

*Main> bestmove g O
[[O,X,O],
 [X,O,O],
 [B,X,B]]
 
-- A non-winning move is returned (first child move of root generated by minimax)


~~~~~~~~~~~~~~~~~~~~~~~~~~~

Node ([[O,X,O],
	   [X,O,B],
	   [B,X,B]],O,1) <- From starting position, possible to win in a single move, but there are three possible moves to select from

[Node ([[O,X,O],
        [X,O,O],
		[B,X,B]],O,2) <- If this move is selected, its still possible to win but now in two moves 

        [Node ([[O,X,O],
		        [X,O,O],
				[X,X,B]],O,1)  <- If X makes this move still possible to win, in 1 move 
								
				[Node ([[O,X,O],
				        [X,O,O],
						[X,X,O]],O,0) []]  <- Winning move 
				
		,Node ([[O,X,O],
				[X,O,O],
				[B,X,X]],O,1)  <- If X makes this move still possible to win, in 1 move 
				
				
				[Node ([[O,X,O],
				        [X,O,O],
						[O,X,X]],O,0) []]], <- Winning move 


Node ([[O,X,O],
       [X,O,B],
       [O,X,B]],O,0) [] <- Winning move 

	   
Node ([[O,X,O],
       [X,O,B],
	   [B,X,O]],O,0) []] <- Winning Move 
	   
Expect the best move to be either of the 0 depth children



-}